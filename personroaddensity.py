# -*- coding: utf-8 -*-
"""personroaddensity

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N2Nl9_rf0ylpZHtuSgbIcTWvYSQDw9-D
"""

!pip install ultralytics

from ultralytics import YOLO

# STEP 1: Install Ultralytics
!pip install ultralytics --quiet

# STEP 2: Import YOLO
from ultralytics import YOLO
import os, zipfile, shutil

# STEP 3: Upload Roboflow ZIP
from google.colab import files
uploaded = files.upload()
# ðŸ‘† Upload the zip file you got from Roboflow

# STEP 4: Unzip dataset to "dataset" folder
zip_name = list(uploaded.keys())[0]
with zipfile.ZipFile(zip_name, 'r') as zip_ref:
    zip_ref.extractall("dataset")

# STEP 5: Rename test -> valid (YOLOv8 needs valid/)
if os.path.exists("dataset/test"):
    # If 'dataset/valid' already exists, remove it first to avoid the error
    if os.path.exists("dataset/valid"):
        shutil.rmtree("dataset/valid")
    os.rename("dataset/test", "dataset/valid")

# STEP 6: Fix the data.yaml file
yaml_path = "dataset/data.yaml"
# Update the paths in data.yaml to be relative to the content root.
# Use absolute paths in data.yaml to avoid path construction issues.
yaml_content = f"""train: /content/dataset/train/images
val: /content/dataset/valid/images
nc: 1
names: ['people']
"""

with open(yaml_path, "w") as f:
    f.write(yaml_content)

# STEP 7: Train YOLOv8
model = YOLO('yolov8n.pt')  # use 'yolov8s.pt' for better accuracy

# Provide the full path to data.yaml
results = model.train(
    data=yaml_path, # Provide the path to your data.yaml file
    epochs=20,
    imgsz=640,
    project="crowd_density_v8"
)

import os
from ultralytics import YOLO
from glob import glob

# Grant permission to access the directory containing the model (Google Colab)
!chmod -R 777 /content/runs/detect/crowd_density_v8

# Check if the best.pt file exists
best_pt_path = "/content/runs/detect/crowd_density_v8/train/weights/best.pt"
if os.path.exists(best_pt_path):
    # Load your trained model if the file exists
    model = YOLO(best_pt_path)
else:
    print(f"Error: best.pt file not found at {best_pt_path}")
    print("Make sure your training completed successfully and the file was saved.")
    # Handle the error, e.g., exit the script or try a different model path

# Continue with predictions if the model was loaded successfully
if 'model' in locals():
    # Get a list of all image files in the directory and subdirectories
    image_files = glob("/content/dataset/valid/images/**/*.jpg", recursive=True)
    image_files = glob("/content/dataset/train/images/**/*.jpg", recursive=True)
    image_files.extend(glob("/content/dataset/valid/images/**/*.jpeg", recursive=True))
    image_files.extend(glob("/content/dataset/valid/images/**/*.png", recursive=True))
    image_files.extend(glob("/content/dataset/valid/images/**/*.bmp", recursive=True))  # Add more extensions if needed

    print(f"Found {len(image_files)} images for prediction.")

    # Run predictions on the list of image files
    results = model.predict(source=image_files, save=True, conf=0.3)

import pandas as pd

counts = []

# Run detection on each image and count people
for img_path in os.listdir("/content/dataset/train/images"):
    full_path = f"/content/dataset/train/images/{img_path}"
    results = model.predict(source=full_path, conf=0.3, verbose=False)
    boxes = results[0].boxes
    person_count = len(boxes)

    # Classify density
    if person_count <= 10:
        density = "Low"
    elif 11 <= person_count <= 25:
        density = "Medium"
    else:
        density = "High"

    counts.append({
        "image": img_path,
        "people_count": person_count,
        "density": density
    })

# Convert to DataFrame and save as CSV
df = pd.DataFrame(counts)
df.to_csv("crowd_density_report.csv", index=False)

df.head()

import matplotlib.pyplot as plt

plt.plot(df.index, df["people_count"], marker='o')
plt.title("Time vs People Count")
plt.xlabel("Frame Index (Time)")
plt.ylabel("People Count")
plt.grid(True)
plt.show()

density_dist = df["density"].value_counts()

plt.bar(density_dist.index, density_dist.values, color=['green', 'orange', 'red'])
plt.title("Crowd Density Category Distribution")
plt.xlabel("Density Category")
plt.ylabel("Number of Frames")
plt.show()